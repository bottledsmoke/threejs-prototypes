import { useRef } from "react";
import { useSprings } from "@react-spring/three";
import { Mesh, Vector3 } from "three";

// TODO Better type config for this return type
interface Api {
  wallSprings: Array<object>;
  cycleWalls: Function;
  setFromIntersects: Function;
}

export default function useNearWallHiding(meshes: Array<Mesh>): Api {
  // TODO Add onClick functionality to enable / disable walls
  // TODO Add hideAll functionality that hides / shows all walls

  interface meshData {
    position: Vector3;
    name: string;
    uuid: string;
    visible: boolean;
  }

  const walls = useRef<Array<meshData>>(
    meshes &&
      meshes.map((el, i) => ({
        position: el.position,
        name: el.name,
        uuid: el.uuid,
        visible: true,
      }))
  );

  const fn2 = (_walls: Array<meshData>) => (index: number) => {
    const curWall = _walls[index];
    const downAmount = -5;
    return {
      xyz: [
        curWall.position.x,
        curWall.visible ? curWall.position.y : downAmount,
        curWall.position.z,
      ],
      opacity: curWall.visible ? 1 : 0,
      config: { tension: 300, friction: 40 },
    };
  };

  const [wallSprings, setSprings] = useSprings(
    walls.current.length,
    fn2(walls.current)
  );

  const _cycleWalls = (nextOrder: Array<number>) => {
    // if (!nextOrder) {
    //   const nextStub = {
    //     WallT: initialRayStub.current.WallL,
    //     WallR: initialRayStub.current.WallT,
    //     WallB: initialRayStub.current.WallR,
    //     WallL: initialRayStub.current.WallB,
    //   };
    //   initialRayStub.current = nextStub;

    //   const stub = walls.current.map((el, i) => ({
    //     ...el,
    //     visible: nextStub[el.name],
    //   }));
    //   walls.current = stub;
    // } else {
    //   const _nextOrder = walls.current.map((el) => ({
    //     ...walls.current[el.uuid],
    //     visible: nextOrder[el.name],
    //   }));
    //   console.log(_nextOrder);
    //   walls.current = _nextOrder;
    // }
    console.warn(
      "CycleWalls is currently deprecated but will return in the future"
    );
    setSprings(fn2(walls.current));
  };

  /**
   * setFromIntersects
   * @param data: Array<number> An array of indices of walls intersected by the raycaster. The indices are generated by mapping
   * the array of walls at their creation.
   */

  const setFromIntersects = (data: Array<number>): void => {
    const a = walls.current.map((el: meshData, i: number) => ({
      ...el,
      visible: !data.some((index: number) => i === index),
    }));
    walls.current = a;
    setSprings(fn2(walls.current));
  };

  // Return API
  return {
    wallSprings,
    cycleWalls: _cycleWalls,
    setFromIntersects: setFromIntersects,
  };
}
